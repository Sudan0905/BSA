bool bsa_set(bsa* b, int indx, int d){
    if (b == NULL || indx < 0) {
        return false; // 检查BSA指针是否有效，以及索引是否在有效范围内
    }

    int row = get_row_from_index(indx);
    if (row >= BSA_ROWS) {
        return false; // 索引超出了bsa结构的容量
    }

    if (b->row_allocated[row]) {
        // 如果这个行已经分配过内存，先释放旧的内存
        free(b->rows[row]);
    }

    // 分配内存
    b->rows[row] = (int*)calloc((1 << row), sizeof(int));
    if (b->rows[row] == NULL) {
        return false; // 内存分配失败
    }
    b->row_allocated[row] = true;

    // 计算行内的实际位置
    int position = indx;
    for (int i = 0; i < row; ++i) {
        position -= (1 << i); // 减去前面行的总大小
    }

    b->rows[row][position] = d;
    b->is_set[indx] = true; // 标记元素为已设置

    if (indx > b->max_index) {
        b->max_index = indx; // 更新最大索引
    }
    return true;
}
