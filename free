bool bsa_delete(bsa* b, int indx){
    if (b == NULL || indx < 0 || indx > b->max_index || !b->is_set[indx]) {
        return false; // 检查BSA指针是否有效，索引是否在有效范围内，以及索引是否已被赋值
    }

    int row = get_row_from_index(indx);
    if (row >= BSA_ROWS || !b->row_allocated[row]) {
        return false; // 如果行超出范围或该行尚未分配，则返回false
    }
    if (!b->is_set[indx]) {
        return false;
    }

    // 计算在行内的实际位置
    int position = indx;
    for (int i = 0; i < row; ++i) {
        position -= (1 << i);
    }

    // 删除元素：将元素值设置为0（或其他标识未使用的值）
    b->rows[row][position] = 0;
    b->is_set[indx] = false; // 标记该索引未被赋值

    // 无论该行是否为空，都释放该行的内存
    free(b->rows[row]);
    b->rows[row] = NULL;
    b->row_allocated[row] = false;

    // 更新max_index为最后一个被标记的元素的索引
    if (indx == b->max_index) {
        while (indx >= 0 && !b->is_set[indx]) {
            indx--;
        }
        b->max_index = indx;
    }

    return true;
}
